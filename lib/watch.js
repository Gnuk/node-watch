/**
 *  Nodewatch (Just another file watcher utility for nodeJS.)
 *  Copyright (c) 2012 yuanchuan (yuanchuan23@gmail.com)
 *  Licensed under the MIT license.
 *  https://github.com/yuanchuan/nodewatch
 */


/**
 *  Module dependencies
 */

var fs   = require('fs')
  , path = require('path');
 

/**
 * Utility functions to synchronously test whether the giving path 
 * is a file or a directory.
 */
var is = (function(ret) {
  ['File', 'Directory'].forEach(function(method) {
    var memo = {}
      , fileObj;
    ret[method] = function(fpath) {
      if (memo[fpath] !== undefined) {
        return memo[fpath];
      }
      try {
        fileObj = fs.statSync(fpath);
      } catch(e) {
        return memo[fpath] = false;
      }
      return memo[fpath] = fileObj['is'+method](fpath); 
    }
  });
  return ret;
}({}));


/**
 *  Filtering files and sub-directories in a directory.
 */
var filter = function(dir) {
  var ret = {};
  ['File', 'Directory'].forEach(function(method){
    ret[method] = function(cb) {
      if (is.Directory(dir)) {
        fs.readdir(dir, function(err, files) {
          files
            .filter(function(n) { return is[method](path.join(dir, n)) })
            .map(function(n) { cb.call(null, path.join(dir, n)) });
        });
      }
    };
  });
  return ret;
};

 
/**
 *  A Container for storing unique filenames.
 */
var fileNameCache = (function(cache) {
  return {
    push: function(name) {
      cache[name] = 1;
      return this;
    },
    each: function() {
      var temp = [];
      for (var name in cache) {
        if (cache.hasOwnProperty(name) && is.File(name)) {
          temp.push(name);
        }
      }
      Array.prototype.forEach.apply(temp, arguments);
      return this;
    },
    clear: function(){
      cache = {};
      return this;
    }
  };
}({}));     


/**
 * Abstracting the way of avoiding duplicate function call.
 */
var worker = (function() {
  var free = true;
  return {
    busydoing: function(cb) {
      if (free) {
        free = false;
        cb.call();
      }
    },
    free: function() {
      free = true;
    }
  }
}());


/**
 * Delay function call and ignore invalid filenames.
 */
var normalizeCall = function(cb, fname) {
  // Store each name of the modifying or temporary files generated by an editor.
  fileNameCache.push(fname);
     
  worker.busydoing(function() {
    // A heuristic delay of the write-to-file process.  
    setTimeout(function() {
      
      // When the write-to-file process is done, send all filtered filenames
      // to the callback function and call it.
      fileNameCache
        .each(function(f) { cb.call(null, f); })
        .clear();

      worker.free();

    }, 100);
  });
};


/**
 * Watch a file or a directory recursively.
 *  
 * @param {String} fpath
 * @param {Function} cb
 * 
 *   watch('fpath', function(file) {
 *     console.log(file, ' changed');
 *   });
 */
function watch(fpath, cb) {

  if (is.File(fpath)) {

    fs.watchFile(fpath, function(err) {
      normalizeCall(cb, fpath);
    });
    return;

  } else if (is.Directory(fpath)) {

    var filtered = filter(fpath);
    try {
      fs.watch(fpath, function(err, fname) {
        normalizeCall(cb,  
          path.join(fpath, fname)
        );
      });
    } catch(e) {
      //In case the system limit of watching a directory using fs.watch method.
      //https://github.com/joyent/node/issues/2479
      filtered.File(function(file) {
        watch(file, cb);
      });
    }
    
    filtered.Directory(function(dir) {
      watch(dir, cb);
    }); 

  } else {
    console.log("Invalid filename or directory.");
  }

}; 
          

// Expose.
module.exports = watch;
          
